#Крипта за тракториста

##Причесываем код
Открываем файл, приводим в нормальный вид, убираем лишние ';', вставляем переводы строк.
Смотрим на размеры того, что читаем. The - массив из 60 элементов, Skillet - матрица 60x60.
Заменеяем в функции всё, зная размеры переменных. Получаем нечто вот такое:
```
def the(lies, that, you):
    if len(lies)!=60:return False
    are=[0 for i in range(60)]
    making=[[False for j in range(len(that[i]))]for i in range(len(that))]
    your=3600
    while your > 0:
        love=despite(0, 59)
        Is=despite(0, 59)
        if not making[love][Is]:
            making[love][Is]=True
            your-=1
            are[love]+=that[love][Is]*ord(lies[Is])
    return are==you
```
##Переходим к криптоанализу
Вначале создается нулевой массив длины 60, который в конце функции проверяется, назовем его главным.
В функции создается матрица 60х60, в каждой ячейке которой хранится False, а также счетчик your размера 3600.
Потом запускается цикл While, в котором случайно генерируются две координаты (назовём их х,y) в матрице.
Потом, если цикл ещё не ходил в ячейку, он в нее ходит, помечает как пройденную и вычитает 1 из счетчика.
```
Это значит, что к каждой ячейке матрицы цикл обращается РОВНО один раз
```
После этого в главный массив в ячейку под номером x прибавляется значение равное значению матрицы в точке (х,y)*ord(flag[y]).
Заметим теперь, что в i-ой ячейке главного массива написана сумма произведений j-ого элемента в i-ой строке на j-й элемент флага.
Тогда пусть ord(flag[j]) = x_j.
В i-ой ячейке массива написано x_1*Matrix[i][1]+...+x_60*Matrix[i][60].
То есть есть система из 60 линейных уравнений с 60 неизвестными.
Такие системы умеет решать почти что угодно, например numpy. 
Скормим ему Skillet и The, потом убедимся в корректном округлении и выведем флаг.
Собственно, флаг: shadowctf{w0w_dud3_y0u_know_l1n344444r_algebra_s0000_go00od}
